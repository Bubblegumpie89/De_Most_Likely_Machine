<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>De 'most likely' machine</title>
    
    <!-- React en ReactDOM laden via CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel laden om JSX te vertalen in de browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS laden voor de styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        /* Voorkom selectie tijdens slepen */
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        // We halen useState en useEffect uit het globale React object
        const { useState, useEffect } = React;

        // --- Data ---
        const mockStudents = [
            { id: 1, name: 'Sophie V.' },
            { id: 2, name: 'Franky D.' },
            { id: 3, name: 'Pascale D.' },
            { id: 4, name: 'Daphné V.' },
            { id: 5, name: 'Déborah P.' },
            { id: 6, name: 'Elke W.' },
            { id: 7, name: 'Freya S.' },
            { id: 8, name: 'Bryan F.' }, 
            { id: 9, name: 'Febe V.' },
            { id: 10, name: 'Tom M.' }, 
        ];

        // Afbeeldingen
        const studentImages = {
            1: 'images/1SophieV',
            2: 'images/1FrankyD',
            3: 'images/1PascaleD',
            4: 'images/1DaphneV',
            5: 'images/1DeborahP',
            6: 'images/1ElkeW',
            7: 'images/1FreyaS',
            8: 'images/1BryanF',   
            9: 'images/1FebeV',    
            10: 'images/1TomM', 
        };

        // --- Trait Card Data ---
        const mockTraitCardsData = [
            { id: 1, name: 'Aanpasbaar' },
            { id: 2, name: 'Avontuurlijk' },
            { id: 3, name: 'Agressief' },
            { id: 4, name: 'Athletisch' },
            { id: 5, name: 'Moedig' },
            { id: 6, name: 'Berekend' },
            { id: 7, name: 'Meeslepend' },
            { id: 8, name: 'Geëngageerd' },
            { id: 9, name: 'Creatief' },
            { id: 10, name: 'Roekeloos' },
            { id: 11, name: 'Toegewijd' },
            { id: 12, name: 'Uitdagend' },
            { id: 13, name: 'Vastberaden' },
            { id: 14, name: 'Gedisciplineerd' },
            { id: 15, name: 'Gedreven' },
            { id: 16, name: 'Grappig' },
            { id: 17, name: 'Onafhankelijk' },
            { id: 18, name: 'Invloedrijk' },
            { id: 19, name: 'Meertalig' },
            { id: 20, name: 'Muzikaal' },
            { id: 21, name: 'Speels' },
            { id: 22, name: 'Rebels' },
            { id: 23, name: 'Onvermoeibaar' },
            { id: 24, name: 'Theatraal' },
            { id: 25, name: 'Taai' },
            { id: 26, name: 'Baanbrekend' },
            { id: 27, name: 'Wraakzuchtig' },
        ];

        const traitImages = {
            1: 'images/Aanpasbaar',
            2: 'images/Avontuurlijk',
            3: 'images/Agressief',
            4: 'images/Athletisch',
            5: 'images/Moedig',
            6: 'images/Berekend',
            7: 'images/Meeslepend',
            8: 'images/Geëngageerd',
            9: 'images/Creatief',
            10: 'images/Roekeloos',
            11: 'images/Toegewijd',
            12: 'images/Uitdagend',
            13: 'images/Vastberaden',
            14: 'images/Gedisciplineerd',
            15: 'images/Gedreven',
            16: 'images/Grappig',
            17: 'images/Onafhankelijk',
            18: 'images/Invloedrijk',
            19: 'images/Meertalig',
            20: 'images/Muzikaal',
            21: 'images/Speels',
            22: 'images/Rebels',
            23: 'images/Onvermoeibaar',
            24: 'images/Theatraal',
            25: 'images/Taai',
            26: 'images/Baanbrekend',
            27: 'images/Wraakzuchtig',
        };

        const traitNameMap = Object.fromEntries(mockTraitCardsData.map(trait => [trait.id, trait.name]));

        const studentScorecards = {
            1: { 1: 4, 2: 15, 3: 9, 4: 1, 5: 11, 6: 19, 7: 7, 8: 14, 9: 3, 10: 17, 11: 20, 12: 6, 13: 13, 14: 10, 15: 18, 16: 5, 17: 12, 18: 2, 19: 16, 20: 8, 21: 1, 22: 19, 23: 14, 24: 7, 25: 11, 26: 20, 27: 5 },
            2: { 1: 18, 2: 10, 3: 3, 4: 14, 5: 8, 6: 17, 7: 2, 8: 12, 9: 19, 10: 5, 11: 16, 12: 1, 13: 11, 14: 20, 15: 7, 16: 15, 17: 4, 18: 9, 19: 13, 20: 6, 21: 18, 22: 2, 23: 10, 24: 17, 25: 1, 26: 14, 27: 8 },
            3: { 1: 6, 2: 1, 3: 16, 4: 11, 5: 19, 6: 4, 7: 13, 8: 20, 9: 8, 10: 15, 11: 2, 12: 10, 13: 18, 14: 5, 15: 12, 16: 17, 17: 7, 18: 14, 19: 1, 20: 9, 21: 16, 22: 3, 23: 11, 24: 20, 25: 6, 26: 13, 27: 18 },
            4: { 1: 10, 2: 19, 3: 5, 4: 12, 5: 3, 6: 17, 7: 9, 8: 1, 9: 15, 10: 7, 11: 14, 12: 20, 13: 4, 14: 11, 15: 18, 16: 6, 17: 13, 18: 2, 19: 17, 20: 9, 21: 16, 22: 1, 23: 12, 24: 5, 25: 20, 26: 8, 27: 15 },
            5: { 1: 1, 2: 13, 3: 18, 4: 7, 5: 15, 6: 2, 7: 10, 8: 17, 9: 5, 10: 12, 11: 20, 12: 8, 13: 16, 14: 3, 15: 11, 16: 19, 17: 6, 18: 14, 19: 1, 20: 10, 21: 17, 22: 4, 23: 19, 24: 9, 25: 15, 26: 7, 27: 2 },
            6: { 1: 12, 2: 7, 3: 1, 4: 16, 5: 11, 6: 9, 7: 18, 8: 4, 9: 14, 10: 20, 11: 3, 12: 10, 13: 17, 14: 8, 15: 15, 16: 2, 17: 13, 18: 19, 19: 6, 20: 11, 21: 1, 22: 18, 23: 5, 24: 16, 25: 10, 26: 14, 27: 7 },
            7: { 1: 16, 2: 3, 3: 11, 4: 19, 5: 8, 6: 1, 7: 14, 8: 20, 9: 6, 10: 13, 11: 2, 12: 10, 13: 17, 14: 5, 15: 12, 16: 18, 17: 9, 18: 15, 19: 4, 20: 1, 21: 11, 22: 20, 23: 7, 24: 14, 25: 2, 26: 18, 27: 8 },
            8: { 1: 9, 2: 20, 3: 7, 4: 13, 5: 2, 6: 11, 7: 18, 8: 5, 9: 16, 10: 1, 11: 10, 12: 19, 13: 3, 14: 15, 15: 8, 16: 12, 17: 17, 18: 6, 19: 14, 20: 20, 21: 4, 22: 9, 23: 1, 24: 11, 25: 18, 26: 7, 27: 13 },
            9: { 1: 3, 2: 11, 3: 17, 4: 9, 5: 14, 6: 20, 7: 6, 8: 12, 9: 1, 10: 19, 11: 8, 12: 16, 13: 5, 14: 13, 15: 2, 16: 18, 17: 10, 18: 15, 19: 7, 20: 14, 21: 20, 22: 4, 23: 9, 24: 17, 25: 1, 26: 12, 27: 6 },
            10: { 1: 5, 2: 12, 3: 18, 4: 9, 5: 3, 6: 14, 7: 20, 8: 1, 9: 11, 10: 16, 11: 7, 12: 19, 13: 4, 14: 10, 15: 15, 16: 8, 17: 2, 18: 13, 19: 17, 20: 6, 21: 10, 22: 5, 23: 18, 24: 1, 25: 14, 26: 9, 27: 12 },
        };

        const PAGES = [
            'home',
            'objectives',
            'introduction',
            'meet-the-class',
            'predict-winners',
            'create-algorithm',
            'tune-algorithm',
            'results',
            'reflection',
            'recap',
        ];

        const MAX_TRAITS_PER_AWARD = 9;

        const awardsConfig = {
            viral: "Meest waarschijnlijk... Viraal te gaan",
            ceo: "Meest waarschijnlijk... CEO te worden",
            troublemaker: "Meest waarschijnlijk... Een marathon te lopen"
        };

        const calculateScores = (awardKey, assignedTraits) => {
            const prioritizedTraits = assignedTraits[awardKey];
            
            if (!prioritizedTraits || prioritizedTraits.length === 0) {
                return mockStudents.map(student => ({ ...student, score: 0 }));
            }

            const traitWeights = {};
            prioritizedTraits.forEach((trait, index) => {
                const weight = MAX_TRAITS_PER_AWARD - index; 
                traitWeights[trait.id] = weight;
            });

            const scoredStudents = mockStudents.map(student => {
                let totalScore = 0;
                const studentScores = studentScorecards[student.id]; 

                prioritizedTraits.forEach(trait => {
                    const traitId = trait.id;
                    const weight = traitWeights[traitId];
                    const studentBaseScore = studentScores[traitId] || 0; 
                    
                    totalScore += (studentBaseScore * weight);
                });
                
                return { ...student, score: totalScore };
            });

            return scoredStudents.sort((a, b) => b.score - a.score);
        };


        // --- Page Components ---

        const PageContainer = ({ children, title, maxWidth = "max-w-5xl" }) => (
            <div className={`flex-grow container mx-auto px-4 sm:px-8 py-12 ${maxWidth}`}>
                <h1 className="text-3xl sm:text-4xl font-bold text-gray-800 mb-8 text-center">{title}</h1>
                {children}
            </div>
        );

        const HomePage = ({ onNext }) => (
            <PageContainer title="De 'most likely' machine">
                <div className="text-center">
                    <h3 className="text-2xl font-semibold text-gray-700 mb-4">
                        Word wijzer over algoritmen
                    </h3>
                    <p className="text-xl text-gray-600 mb-12 max-w-2xl mx-auto">
                        Algoritmen drijven de wereld aan, maar ze kunnen fouten maken. Bouw je eigen algoritme en zie welke impact het heeft - ten goede en ten kwade.
                    </p>
                    <div className="w-full max-w-md h-64 bg-gray-300 rounded-lg mx-auto mb-12 shadow-lg overflow-hidden">
                        <img
                            src="images/2Machine" 
                            alt="Machine"
                            className="w-full h-full object-cover"
                            onError={(e) => { e.target.src = 'https://placehold.co/600x400/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                        />
                    </div>
                    <button
                        onClick={onNext}
                        className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full text-lg transition duration-300 shadow-md hover:shadow-lg"
                    >
                        Start
                    </button>
                </div>
            </PageContainer>
        );

        const ObjectivesPage = ({ onNext }) => (
            <PageContainer title="Kom meer te weten over...">
                <div className="bg-white p-8 rounded-lg shadow-xl flex flex-col md:flex-row justify-around items-start gap-6">
                    
                    <div className="text-center flex-1 min-w-[150px]">
                        <div className="w-full max-w-xs h-48 bg-gray-300 rounded-lg mx-auto mb-4 shadow-md flex items-center justify-center overflow-hidden">
                            <img
                                src="images/2What"
                                alt="What"
                                className="w-full h-full object-cover"
                                onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                            />
                        </div>
                        <h2 className="text-2xl font-semibold text-gray-800">Wat zijn algoritmes?</h2>
                    </div>

                    <div className="text-center flex-1 min-w-[150px]">
                        <div className="w-full max-w-xs h-48 bg-gray-300 rounded-lg mx-auto mb-4 shadow-md flex items-center justify-center overflow-hidden">
                            <img
                                src="images/2Used"
                                alt="Used"
                                className="w-full h-full object-cover"
                                onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                            />
                        </div>
                        <h2 className="text-2xl font-semibold text-gray-800">Waarvoor worden ze gebruikt?</h2>
                    </div>

                    <div className="text-center flex-1 min-w-[150px]">
                        <div className="w-full max-w-xs h-48 bg-gray-300 rounded-lg mx-auto mb-4 shadow-md flex items-center justify-center overflow-hidden">
                            <img
                                src="images/2Bias"
                                alt="Bias"
                                className="w-full h-full object-cover"
                                onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                            />
                        </div>
                        <h2 className="text-2xl font-semibold text-gray-800">Wat is algoritmische bias?</h2>
                    </div>

                    <div className="text-center flex-1 min-w-[150px]">
                        <div className="w-full max-w-xs h-48 bg-gray-300 rounded-lg mx-auto mb-4 shadow-md flex items-center justify-center overflow-hidden">
                            <img
                                src="images/2Why"
                                alt="Why"
                                className="w-full h-full object-cover"
                                onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                            />
                        </div>
                        <h2 className="text-2xl font-semibold text-gray-800">Waarom is het belangrijk?</h2>
                    </div>

                </div>
            </PageContainer>
        );

        const IntroductionPage = ({ onNext }) => (
            <PageContainer title="Opdracht">
                <div className="max-w-3xl mx-auto space-y-6 text-lg text-gray-700">
                    <p>
                        Dit jaar delen we bij AGO de "most likely..."-awards uit.
                    </p>
                    <div className="w-full h-56 bg-gray-300 rounded-lg shadow-md overflow-hidden">
                        <img
                            src="images/2Award" 
                            alt="Award" 
                            className="w-full h-full object-cover"
                            onError={(e) => { e.target.src = 'https://placehold.co/600x400/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                        />
                    </div>
                    <p>
                        Maar wat als deze voorspellingen door een machine werden gedaan?
                    </p>
                    <p>
                        Jij zal beslissen over drie prijzen: "Meest waarschijnlijk... Viraal te gaan", "Meest waarschijnlijk... CEO te worden" en "Meest waarschijnlijk... Een marathon te lopen." Eerst gebruik je je intuïtie. Daarna ontwerp je algoritmen om het werk voor je te doen.
                    </p>
                </div>
            </PageContainer>
        );

        const StudentCard = ({ student }) => {
            const scores = studentScorecards[student.id];
            const topTraits = Object.entries(scores) 
                .sort(([, scoreA], [, scoreB]) => scoreB - scoreA) 
                .slice(0, 3) 
                .map(([traitId, score]) => ({
                    name: traitNameMap[traitId], 
                    score: score,
                }));

            return (
                <div className="bg-white rounded-lg shadow-lg p-4 relative transition-all duration-300 flex flex-col">
                    <img
                        src={studentImages[student.id]}
                        alt={student.name}
                        className="w-full h-40 object-cover rounded-md mb-4" 
                        onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld+niet+gevonden'; e.target.onerror = null; }}
                    />
                    <h3 className="font-bold text-lg text-gray-800 mb-2">{student.name}</h3>
                    <div className="flex-grow">
                        <h4 className="font-semibold text-sm text-gray-500 mb-2">Topkenmerken:</h4>
                        <ul className="text-sm text-gray-600 space-y-1">
                            {topTraits.map((trait, index) => (
                                <li key={trait.name} className="flex justify-between">
                                    <span>{trait.name}</span>
                                    <span className="font-bold text-blue-600">{trait.score} / 20</span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            );
        };

        const MeetTheClassPage = ({ onNext }) => (
            <PageContainer title="Maak kennis met de finalisten" maxWidth="max-w-7xl">
                <p className="text-center text-lg text-gray-600 mb-8 max-w-2xl mx-auto">
                    Je zit in het prijzencomité. Jouw taak is om de "Most likely..."-awards van dit jaar uit te reiken. Maak hieronder kennis met de 10 finalisten voordat je stemt.
                </p>
                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-5 gap-6">
                    {mockStudents.map(student => (
                        <StudentCard key={student.id} student={student} />
                    ))}
                </div>
            </PageContainer>
        );

        const AwardSelector = ({ awardKey, awardLabel, selectedId, setSelections }) => {
            const handleSelect = (e) => {
                const studentId = e.target.value ? parseInt(e.target.value, 10) : null;
                setSelections(prev => ({
                    ...prev,
                    [awardKey]: studentId
                }));
            };

            const selectedStudent = selectedId ? mockStudents.find(s => s.id === selectedId) : null;

            return (
                <div className="bg-white p-6 rounded-lg shadow-xl mb-8">
                    <label className="block text-xl font-semibold text-gray-800 mb-4" htmlFor={`select-${awardKey}`}>
                        {awardLabel}
                    </label>
                    <select
                        id={`select-${awardKey}`}
                        value={selectedId || ''}
                        onChange={handleSelect}
                        className="w-full p-3 border border-gray-300 rounded-lg text-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
                    >
                        <option value="">Selecteer een kandidaat...</option>
                        {mockStudents.map(student => (
                            <option key={student.id} value={student.id}>
                                {student.name}
                            </option>
                        ))}
                    </select>

                    {selectedStudent && (
                        <div className="mt-6 p-4 bg-gray-100 rounded-lg flex items-center space-x-4">
                            <img
                                src={studentImages[selectedStudent.id]}
                                alt={selectedStudent.name}
                                className="w-20 h-20 object-cover rounded-md"
                                onError={(e) => { e.target.src = 'https://placehold.co/100x100/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                            />
                            <div>
                                <h4 className="font-bold text-lg text-gray-800">{selectedStudent.name}</h4>
                                <p className="text-gray-600">Jouw intuïtieve keuze</p>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const PredictWinnersPage = ({ onNext, selections, setSelections }) => {
            return (
                <PageContainer title="Voorspel de winnaars">
                    <p className="text-center text-lg text-gray-600 mb-8 max-w-2xl mx-auto">
                        Selecteer op basis van je intuïtie één winnaar voor elke prijs met behulp van de dropdownmenu's hieronder.
                    </p>
                    
                    <div className="max-w-2xl mx-auto">
                        {Object.keys(awardsConfig).map(key => (
                            <AwardSelector
                                key={key}
                                awardKey={key}
                                awardLabel={awardsConfig[key]}
                                selectedId={selections[key]}
                                setSelections={setSelections}
                            />
                        ))}
                    </div>
                </PageContainer>
            );
        };

        const AlgorithmTraitCard = ({ trait, onDragStart, isDraggable }) => (
            <div
                draggable={isDraggable}
                onDragStart={isDraggable ? onDragStart : null}
                
                className={`w-[36rem] h-[22rem] rounded-lg shadow-xl overflow-hidden relative group ${isDraggable ? 'cursor-grab active:cursor-grabbing' : 'opacity-50 cursor-not-allowed'}`}
            >
                <img
                    src={traitImages[trait.id]}
                    alt={trait.name}
                    className="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                    onError={(e) => { e.target.src = 'https://placehold.co/256x128/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                />
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center">
                    <h3 className="font-bold text-3xl text-white text-center p-2" style={{ textShadow: '1px 1px 2px rgba(0,0,0,0.7)' }}>
                        {trait.name}
                    </h3>
                </div>
                {!isDraggable && (
                    <div className="absolute inset-0 bg-gray-500 bg-opacity-50" />
                )}
            </div>
        );


        const AwardTraitDropZone = ({ awardKey, awardLabel, onDrop, onDragOver, children, isDragOver, traitCount, maxTraits }) => {
            const isFull = traitCount >= maxTraits;
            return (
                <div
                    onDrop={onDrop}
                    onDragOver={onDragOver}
                    data-award-key={awardKey}
                    className={`w-full md:w-1/3 bg-gray-100 p-4 rounded-lg shadow-inner min-h-[10rem] transition-colors ${
                        isDragOver && !isFull ? 'bg-blue-100 ring-2 ring-blue-500' : ''
                    } ${isFull ? 'bg-green-50 border-2 border-green-300' : 'border-2 border-transparent'}`}
                >
                    <h3 className="text-xl font-semibold text-gray-800 text-center mb-2">{awardLabel}</h3>
                    <div className="text-center font-medium text-gray-600 mb-4">
                        {traitCount} / {maxTraits} kenmerken
                    </div>
                    <div className="grid grid-cols-3 gap-2 justify-center">
                        {children}
                    </div>
                    {isFull && (
                        <div className="text-center text-green-700 font-semibold mt-4 col-span-3">
                            Voltooid!
                        </div>
                    )}
                </div>
            );
        };

        // [NIEUWE COMPONENT] AssignedTraitCard
        // Vervangt de AssignedTraitPill om de afbeelding te tonen en draggable te zijn.
        const AssignedTraitCard = ({ trait, onDragStart }) => (
            <div
                draggable
                onDragStart={onDragStart}
                className="relative w-full h-20 rounded-md shadow-sm overflow-hidden cursor-grab active:cursor-grabbing group border border-gray-200"
            >
                <img
                    src={traitImages[trait.id]}
                    alt={trait.name}
                    className="w-full h-full object-cover opacity-90 group-hover:opacity-100 transition-opacity"
                    onError={(e) => { e.target.src = 'https://placehold.co/150x80/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                />
                <div className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center">
                    <span className="font-bold text-white text-center px-1 text-sm" style={{ textShadow: '1px 1px 2px black' }}>
                        {trait.name}
                    </span>
                </div>
            </div>
        );

        const CreateAlgorithmPage = ({ onNext, assignedTraits, setAssignedTraits }) => {
            const [draggedTrait, setDraggedTrait] = useState(null);
            const [dragOverZone, setDragOverZone] = useState(null);

            const [remainingTraits, setRemainingTraits] = useState(() => {
                const assignedIds = new Set([
                    ...assignedTraits.viral.map(t => t.id),
                    ...assignedTraits.ceo.map(t => t.id),
                    ...assignedTraits.troublemaker.map(t => t.id),
                ]);

                return mockTraitCardsData
                    .filter(trait => !assignedIds.has(trait.id))
                    .reverse(); 
            });

            const currentTrait = remainingTraits.length > 0 ? remainingTraits[remainingTraits.length - 1] : null;

            const handleDragStart = (trait) => (e) => {
                e.dataTransfer.setData("traitId", trait.id);
                setDraggedTrait(trait);
            };
            
            const handleDragOver = (e) => {
                e.preventDefault();  
                const targetZone = e.currentTarget.dataset.awardKey;
                if (targetZone) {
                    // Staat drop toe, zolang de limiet niet bereikt is, OF als we iets uit dezelfde zone verplaatsen (al is dat hier minder relevant)
                    if (assignedTraits[targetZone].length < MAX_TRAITS_PER_AWARD) {
                        setDragOverZone(targetZone);
                    } else {
                        // Als de zone vol is, maar we slepen iets dat al in deze zone zit?
                        // Voor nu: als vol, geen drop indicator.
                        // We kunnen evt controleren of het gesleepte item al in de doelzone zit.
                        const traitId = parseInt(e.dataTransfer.getData("traitId") || draggedTrait?.id, 10);
                        const isAlreadyHere = assignedTraits[targetZone].some(t => t.id === traitId);
                        
                        if (isAlreadyHere) {
                             setDragOverZone(targetZone); // Toestaan om te herordenen (al doen we nu alleen append)
                        } else {
                             setDragOverZone(null);  
                        }
                    }
                }
            };

            const handleDragLeave = () => {
                setDragOverZone(null);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setDragOverZone(null);  
                const traitId = parseInt(e.dataTransfer.getData("traitId"), 10);
                const targetAwardKey = e.currentTarget.dataset.awardKey;

                if (!traitId || !targetAwardKey || !draggedTrait) return;

                // --- LOGICA AANGEPAST ---
                
                // 1. Zoek waar de kaart vandaan komt (Stack of een andere categorie)
                let sourceCategory = null;
                
                // Check of het van de stapel komt (moet de bovenste zijn)
                const isFromStack = currentTrait && traitId === currentTrait.id;

                // Check of het uit een bestaande categorie komt
                if (!isFromStack) {
                    for (const key of Object.keys(assignedTraits)) {
                        if (assignedTraits[key].some(t => t.id === traitId)) {
                            sourceCategory = key;
                            break;
                        }
                    }
                }

                // 2. Validatie: Mag het hier gedropt worden?
                const targetList = assignedTraits[targetAwardKey];
                const isAlreadyInTarget = targetList.some(t => t.id === traitId);
                
                // Als doel vol is EN het item zit er nog niet in -> stop
                if (targetList.length >= MAX_TRAITS_PER_AWARD && !isAlreadyInTarget) {
                    return; 
                }

                // 3. Voer verplaatsing uit
                if (isFromStack) {
                    // Van Stapel -> Categorie
                    setAssignedTraits(prev => ({
                        ...prev,
                        [targetAwardKey]: [...prev[targetAwardKey], draggedTrait]
                    }));
                    setRemainingTraits(prev => prev.slice(0, -1));
                } else if (sourceCategory) {
                    // Van Categorie -> Categorie
                    
                    // Als bron en doel hetzelfde zijn, doen we (voorlopig) niks, of verplaatsen we naar achteren.
                    if (sourceCategory === targetAwardKey) return;

                    setAssignedTraits(prev => {
                        // Verwijder uit bron
                        const newSourceList = prev[sourceCategory].filter(t => t.id !== traitId);
                        // Voeg toe aan doel
                        const newTargetList = [...prev[targetAwardKey], draggedTrait];
                        
                        return {
                            ...prev,
                            [sourceCategory]: newSourceList,
                            [targetAwardKey]: newTargetList
                        };
                    });
                }
                
                setDraggedTrait(null);
            };
            
            const handleDragEnd = () => {
                setDraggedTrait(null);
                setDragOverZone(null);
            };

            return (
                // [AANGEPAST] Bredere container om de 3 kolommen per award te accommoderen
                <PageContainer title="Creëer het algoritme" maxWidth="max-w-[1600px]">
                    <p className="text-center text-lg text-gray-600 mb-8 max-w-2xl mx-auto">
                        Nu gaan we jouw "algoritme" bouwen. Sleep elk kenmerk van de stapel en laat het vallen op de prijs waarvoor je denkt dat het het meest relevant is. Elke prijs heeft {MAX_TRAITS_PER_AWARD} kenmerken nodig.
                    </p>

                    {/* Card Stack */}
                    
                    <div className="h-[26rem] flex items-center justify-center relative mb-8">
                        {remainingTraits.length > 0 ? (
                            remainingTraits.map((trait, index) => {
                                const isTopCard = index === remainingTraits.length - 1;
                                return (
                                    <div
                                        key={trait.id}
                                        className="absolute transition-all"
                                        style={{
                                            transform: `translate(${index * -2}px, ${index * -2}px)`,
                                            zIndex: index,
                                            opacity: isTopCard ? 1 : (1 - (remainingTraits.length - index) * 0.1),
                                            filter: isTopCard ? 'none' : 'blur(2px)'
                                        }}
                                    >
                                        <AlgorithmTraitCard
                                            trait={trait}
                                            onDragStart={handleDragStart(trait)}
                                            isDraggable={isTopCard}
                                        />
                                    </div>
                                );
                            })
                        ) : (
                            <p className="text-xl text-gray-500">Alle kenmerken toegewezen! Ga naar de volgende pagina om je algoritme te verfijnen.</p>
                        )}
                    </div>

                    {/* Drop Zones */}
                    <div 
                        className="flex flex-col md:flex-row gap-6"
                        onDragLeave={handleDragLeave}
                        onDragEnd={handleDragEnd}
                    >
                        {Object.keys(awardsConfig).map(key => (
                            <AwardTraitDropZone
                                key={key}
                                awardKey={key}
                                awardLabel={awardsConfig[key]}
                                onDrop={handleDrop}
                                onDragOver={handleDragOver}
                                isDragOver={dragOverZone === key}
                                traitCount={assignedTraits[key].length}
                                maxTraits={MAX_TRAITS_PER_AWARD}
                            >
                                {/* [AANGEPAST] Gebruik nu AssignedTraitCard i.p.v. AssignedTraitPill */}
                                {assignedTraits[key].map(trait => (
                                    <AssignedTraitCard 
                                        key={trait.id} 
                                        trait={trait} 
                                        onDragStart={handleDragStart(trait)}
                                    />
                                ))}
                            </AwardTraitDropZone>
                        ))}
                    </div>
                </PageContainer>
            );
        };

        const DraggableTraitItem = ({ trait, position, onDragStart, onDragOver, onDrop, onDragEnd, isDragging, isDropTargetBefore, isDropTargetAfter }) => {
            let borderClass = 'border-y-transparent';
            if (isDropTargetBefore) {
                borderClass = 'border-t-blue-500 border-b-transparent';
            } else if (isDropTargetAfter) {
                borderClass = 'border-b-blue-500 border-t-transparent';
            }
            
            const containerClass = `
                p-4 bg-white rounded-lg shadow-md flex items-center justify-between 
                cursor-grab active:cursor-grabbing transition-colors duration-100 ease-in-out
                ${isDragging ? 'opacity-50' : 'opacity-100'}
                border-t-8 border-b-8 ${borderClass}
            `;

            return (
              <div
                draggable
                onDragStart={onDragStart}
                onDragOver={onDragOver}
                onDrop={onDrop}
                onDragEnd={onDragEnd}
                data-trait-id={trait.id}
                className={containerClass}
              >
                <div className="flex items-center">
                  <span className="font-bold text-lg text-blue-600 w-6 text-right mr-3">{position}.</span>
                  <span className="font-medium text-gray-700">{trait.name}</span>
                </div>

                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16m-7 6h7" />
                </svg>
              </div>
            );
        };

        const TuneAlgorithmPage = ({ onNext, assignedTraits, setAssignedTraits }) => {
            const [selectedAward, setSelectedAward] = useState(Object.keys(awardsConfig)[0]);  
            const [draggedTraitId, setDraggedTraitId] = useState(null);
            const [dropIndicator, setDropIndicator] = useState({ targetId: null, position: 'before' });

            const handleDragStart = (e) => {
                const traitId = parseInt(e.currentTarget.dataset.traitId, 10);
                setDraggedTraitId(traitId);
                e.dataTransfer.setData("traitId", traitId);
                e.dataTransfer.effectAllowed = "move";
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                const targetElement = e.currentTarget;
                const targetTraitId = parseInt(targetElement.dataset.traitId, 10);
                
                if (!targetTraitId || targetTraitId === draggedTraitId) return;

                const rect = targetElement.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;
                const position = e.clientY < midY ? 'before' : 'after';

                if (dropIndicator.targetId !== targetTraitId || dropIndicator.position !== position) {
                    setDropIndicator({ targetId: targetTraitId, position });
                }
            };

            const handleDragLeaveContainer = () => {
                setDropIndicator({ targetId: null, position: 'before' });
            };

            const handleDrop = (e) => {
                e.preventDefault();
                
                if (!dropIndicator.targetId || !draggedTraitId || dropIndicator.targetId === draggedTraitId) {
                    setDraggedTraitId(null);
                    setDropIndicator({ targetId: null, position: 'before' });
                    return;
                }

                const currentTraits = [...assignedTraits[selectedAward]];
                
                const draggedIndex = currentTraits.findIndex(t => t.id === draggedTraitId);
                if (draggedIndex === -1) {
                    setDraggedTraitId(null);
                    setDropIndicator({ targetId: null, position: 'before' });
                    return;
                }
                const draggedItem = currentTraits.splice(draggedIndex, 1)[0];
                
                if (!draggedItem) {
                    setDraggedTraitId(null);
                    setDropIndicator({ targetId: null, position: 'before' });
                    return;
                }

                let targetIndex = currentTraits.findIndex(t => t.id === dropIndicator.targetId);

                if (dropIndicator.position === 'after') {
                    targetIndex++;
                }
                
                currentTraits.splice(targetIndex, 0, draggedItem);

                setAssignedTraits(prev => ({
                    ...prev,
                    [selectedAward]: currentTraits
                }));
                
                setDraggedTraitId(null);
                setDropIndicator({ targetId: null, position: 'before' });
            };

            const handleDragEnd = () => {
                setDraggedTraitId(null);
                setDropIndicator({ targetId: null, position: 'before' });
            };

            const currentTraits = assignedTraits[selectedAward];

            return (
                <PageContainer title="Verfijn het algoritme">
                    <p className="text-center text-lg text-gray-600 mb-8 max-w-2xl mx-auto">
                        Geef nu prioriteit aan de kenmerken voor elk algoritme. Klik op een prijs en sleep de kenmerken om ze opnieuw te ordenen van meest belangrijk (boven) naar minst belangrijk (onder).
                    </p>

                    <div className="flex justify-center gap-4 mb-8">
                        {Object.keys(awardsConfig).map(key => (
                            <button
                                key={key}
                                onClick={() => setSelectedAward(key)}
                                className={`py-3 px-6 rounded-full font-semibold transition-all ${
                                    selectedAward === key
                                        ? 'bg-blue-600 text-white shadow-lg'
                                        : 'bg-white text-gray-700 shadow-md hover:bg-gray-100'
                                }`}
                            >
                                {awardsConfig[key]}
                            </button>
                        ))}
                    </div>

                    <div className="max-w-md mx-auto bg-gray-100 p-6 rounded-lg shadow-inner">
                        <h3 className="text-xl font-semibold text-gray-800 mb-4 text-center">{awardsConfig[selectedAward]}</h3>
                        {currentTraits.length > 0 ? (
                            <div className="space-y-0" onDragEnd={handleDragEnd} onDragLeave={handleDragLeaveContainer}> 
                                {currentTraits.map((trait, index) => (
                                    <DraggableTraitItem
                                        key={trait.id}
                                        trait={trait}
                                        position={index + 1}
                                        isDragging={draggedTraitId === trait.id}
                                        onDragStart={handleDragStart}
                                        onDragOver={handleDragOver}
                                        onDrop={handleDrop}
                                        onDragEnd={handleDragEnd}
                                        isDropTargetBefore={dropIndicator.targetId === trait.id && dropIndicator.position === 'before'}
                                        isDropTargetAfter={dropIndicator.targetId === trait.id && dropIndicator.position === 'after'}
                                    />
                                ))}
                            </div>
                        ) : (
                            <p className="text-gray-500 text-center italic py-4">
                                Geen kenmerken toegewezen aan deze prijs. Ga terug naar "Creëer Je Algoritmen" om ze toe te voegen.
                            </p>
                        )}
                    </div>
                </PageContainer>
            );
        };

        const ResultsModal = ({ modalData, onClose }) => {
            if (!modalData) return null;

            const { awardKey, leaderboard, traits } = modalData;
            const winner = leaderboard[0];
            const runnersUp = leaderboard.slice(1, 4);

            return (
                <div
                    className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
                    onClick={onClose} 
                >
                    <div
                        className="bg-white rounded-lg shadow-2xl p-6 sm:p-8 max-w-2xl w-full max-h-[90vh] overflow-y-auto"
                        onClick={(e) => e.stopPropagation()} 
                    >
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-2xl sm:text-3xl font-bold text-gray-800">{awardsConfig[awardKey]}</h2>
                            <button
                                onClick={onClose}
                                className="text-gray-400 hover:text-gray-600 transition-colors"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>

                        <div className="mb-8">
                            <h3 className="text-xl font-semibold text-gray-700 mb-4">Eindklassement</h3>
                            <ol className="space-y-3">
                                <li className="flex items-center justify-between bg-yellow-100 p-4 rounded-lg shadow-md">
                                    <span className="text-lg font-bold text-yellow-800">1. {winner.name}</span>
                                    <span className="text-lg font-bold text-yellow-800">{winner.score.toLocaleString()} pnt</span>
                                </li>
                                {runnersUp.map((student, index) => (
                                    <li key={student.id} className="flex items-center justify-between bg-gray-100 p-3 rounded-md">
                                        <span className="text-base font-medium text-gray-700">{index + 2}. {student.name}</span>
                                        <span className="text-base font-medium text-gray-600">{student.score.toLocaleString()} pnt</span>
                                    </li>
                                ))}
                            </ol>
                        </div>

                        <div>
                            <h3 className="text-xl font-semibold text-gray-700 mb-4">Waarom heeft {winner.name} gewonnen?</h3>
                            <p className="text-gray-600 text-base mb-6">
                                Toen je het algoritme ontwierp, heb je het geleerd om 9 persoonlijkheidskenmerken te herkennen als de beste voor deze prijs. Je hebt er ook één als belangrijkste gerangschikt, wat betekent dat het 9 punten waard is, waarbij elk volgend kenmerk in punten afneemt.
                            </p>
                            <div className="bg-gray-50 p-4 rounded-lg border">
                                <h4 className="text-base font-semibold text-gray-700 mb-3">Jouw Kenmerk-rangschikking & Punten</h4>
                                <ul className="space-y-2">
                                    {traits.map((trait, index) => (
                                        <li key={trait.id} className="flex justify-between items-center text-sm">
                                            <span className="font-medium text-gray-600">{trait.name}</span>
                                            <span className="font-bold text-blue-600">{MAX_TRAITS_PER_AWARD - index} pnt</span>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        </div>

                        <button
                            onClick={onClose}
                            className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300 shadow-md hover:shadow-lg mt-8"
                        >
                            Sluiten
                        </button>
                    </div>
                </div>
            );
        };

        const ResultsPage = ({ onNext, selections, assignedTraits }) => {
            const [algorithmPicks, setAlgorithmPicks] = useState({
                viral: null,
                ceo: null,
                troublemaker: null
            });
            
            const [modalData, setModalData] = useState(null); 

            useEffect(() => {
                const calculateResults = () => {
                    const picks = {};

                    Object.keys(awardsConfig).forEach(awardKey => {
                        const leaderboard = calculateScores(awardKey, assignedTraits);
                        picks[awardKey] = leaderboard[0]; 
                    });
                    
                    setAlgorithmPicks(picks);
                };

                calculateResults();
            }, [assignedTraits]);

            const handleLearnWhy = (awardKey) => {
                const leaderboard = calculateScores(awardKey, assignedTraits);
                const traits = assignedTraits[awardKey] || [];
                setModalData({ awardKey, leaderboard, traits });
            };

            const getStudentName = (student) => {
                if (!student) return <span className="text-gray-500 italic">Niemand geselecteerd</span>;
                return student.name;
            };

            const getStudentById = (id) => {
                if (!id) return null;
                return mockStudents.find(s => s.id === id);
            }

            const resultsAwardTitles = {
                viral: "Most likely... Viraal te gaan",
                ceo: "Most likely... CEO te worden",
                troublemaker: "Most likely... Een marathon te lopen"
            };

            return (
                <PageContainer title="De resultaten" maxWidth="max-w-7xl">
                    <div className="text-center mx-auto">
                        <h2 className="text-2xl font-semibold text-gray-700 mb-8">Jouw intuïtie vs. het algoritme</h2>
                        
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                            {Object.keys(awardsConfig).map(key => {
                                const userPick = getStudentById(selections[key]);
                                const algorithmPick = algorithmPicks[key];

                                return (
                                    <div key={key} className={`bg-white p-6 rounded-lg shadow-xl flex flex-col`}>
                                        <h3 className="text-xl font-bold text-gray-800 mb-6 text-center">
                                            {resultsAwardTitles[key]}
                                        </h3>
                                        
                                        <div className="space-y-4 text-left flex-grow">
                                            
                                            <div>
                                                <p className="text-2xl font-bold text-purple-600">{getStudentName(algorithmPick)}</p>
                                                <h4 className="text-sm font-semibold text-gray-600 mt-1">De keuze van je algoritme</h4> 
                                            </div>

                                            {algorithmPick && (
                                                <div className="mt-4">
                                                    <img
                                                        src={studentImages[algorithmPick.id]}
                                                        alt={algorithmPick.name}
                                                        className="w-full aspect-square object-cover object-top rounded-md shadow-md" 
                                                        onError={(e) => { e.target.src = 'https://placehold.co/400x400/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                                                    />
                                                </div>
                                            )}
                                        </div>

                                        <div className="text-left mt-6"> 
                                            <h4 className="text-sm font-semibold text-gray-600">Jouw intuïtieve keuze:</h4>
                                            <p className="text-lg font-medium text-blue-600">{getStudentName(userPick)}</p>
                                        </div>

                                        <button
                                            onClick={() => handleLearnWhy(key)}
                                            className="mt-6 w-full bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition-colors"
                                        >
                                            Ontdek waarom
                                        </button>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                    
                    <ResultsModal modalData={modalData} onClose={() => setModalData(null)} />
                </PageContainer>
            );
        };

        const ReflectionPage = ({ onNext }) => (
            <PageContainer title="Reflectie">
                <div className="max-w-3xl mx-auto space-y-8 text-lg text-gray-700">
                    
                    <div className="bg-white p-8 rounded-lg shadow-xl">
                        <h2 className="text-2xl font-semibold text-gray-800 mb-4">Intuïtie vs. Data</h2>
                        
                        <p className="mb-4">
                          Op de pagina 'Voorspel de winnaars' kozen jullie op gevoel.
                        </p>
                        <p className="mb-6">
                          Bij 'De resultaten' kwam er een berekende winnaar uit.
                        </p>

                        <div className="w-full h-56 bg-gray-300 rounded-lg shadow-md flex items-center justify-center my-8">
                             <img
                                src="images/2Balans" 
                                alt="Reflectie"
                                className="w-full h-full object-cover rounded-lg"
                                onError={(e) => { e.target.src = 'https://placehold.co/600x400/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                            />
                        </div>
                        
                        <div className="space-y-6">
                            {/* Vraag 1 */}
                            <div className="flex items-start space-x-4 bg-gray-50 p-6 rounded-xl border border-gray-200 shadow-sm">
                                <div className="flex-shrink-0 w-12 h-12 bg-blue-600 text-white rounded-full flex items-center justify-center text-2xl font-bold shadow-md">
                                    1
                                </div>
                                <div className="flex items-center h-12">
                                    <p className="text-lg font-semibold text-gray-800">
                                        Welke uitslag voelt 'juister'?
                                    </p>
                                </div>
                            </div>

                            {/* Vraag 2 */}
                            <div className="flex items-start space-x-4 bg-gray-50 p-6 rounded-xl border border-gray-200 shadow-sm">
                                <div className="flex-shrink-0 w-12 h-12 bg-blue-600 text-white rounded-full flex items-center justify-center text-2xl font-bold shadow-md">
                                    2
                                </div>
                                <div>
                                    <p className="text-lg font-semibold text-gray-800">
                                        Als je gevoel zegt dat het algoritme fout zit, zit de fout dan in de formule waarmee de scores berekend worden of in de gegevens van de kandidaten?
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </PageContainer>
        );

        const RecapPage = ({ onNext }) => (
            <PageContainer title="Conclusie">
                <div className="max-w-3xl mx-auto bg-white p-8 rounded-lg shadow-xl text-lg text-gray-700 space-y-4">
                    
                    <p>
                        <strong>Algoritmen zijn hulpmiddelen die door mensen zijn gebouwd.</strong> Ze weerspiegelen de doelen, waarden en vooroordelen van hun makers.
                    </p>
                    <div className="w-full rounded-lg shadow-md flex items-center justify-center my-4 overflow-hidden">
                        <img
                            src="images/2What" 
                            alt="Tools"
                            className="w-full aspect-square object-cover"
                            onError={(e) => { e.target.src = 'https://placehold.co/600x600/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                        />
                    </div>

                    <p>
                        <strong>Verschillende inputs en gewichten leiden tot verschillende uitkomsten.</strong> Een kleine wijziging in de regels van een algoritme kan een grote impact hebben op het resultaat.
                    </p>
                    <div className="w-full rounded-lg shadow-md flex items-center justify-center my-4 overflow-hidden">
                        <img
                            src="images/2Used" 
                            alt="Inputs"
                            className="w-full aspect-square object-cover"
                            onError={(e) => { e.target.src = 'https://placehold.co/600x600/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                        />
                    </div>

                    <p>
                        <strong>"Eerlijkheid" is complex.</strong> Een algoritme dat op het eerste gezicht neutraal lijkt, kan nog steeds oneerlijke resultaten opleveren als de gegevens vooringenomen zijn.
                    </p>
                    <div className="w-full rounded-lg shadow-md flex items-center justify-center my-4 overflow-hidden">
                        <img
                            src="images/2Bias" 
                            alt="Fairness"
                            className="w-full aspect-square object-cover"
                            onError={(e) => { e.target.src = 'https://placehold.co/600x600/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                        />
                    </div>

                    <p>
                        <strong>Transparantie is cruciaal.</strong> Het is belangrijk om jezelf de vraag te stellen welke factoren een algoritme gebruikt en hoe het wordt "afgesteld".
                    </p>
                    <div className="w-full rounded-lg shadow-md flex items-center justify-center my-4 overflow-hidden">
                        <img
                            src="images/2Why" 
                            alt="Transparency"
                            className="w-full aspect-square object-cover"
                            onError={(e) => { e.target.src = 'https://placehold.co/600x600/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
                        />
                    </div>
                    
                    <div className="text-center pt-8">
                        <button
                            onClick={() => onNext(0)} 
                            className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full text-lg transition duration-300 shadow-md hover:shadow-lg"
                        >
                            Opnieuw Beginnen
                        </button>
                    </div>
                </div>
            </PageContainer>
        );

        const Navigation = ({ currentPageIndex, setCurrentPage }) => {
            const onNext = () => {
                if (currentPageIndex < PAGES.length - 1) {
                    setCurrentPage(currentPageIndex + 1);
                }
            };

            const onBack = () => {
                if (currentPageIndex > 0) {
                    setCurrentPage(currentPageIndex - 1);
                }
            };

            const canGoBack = currentPageIndex > 0;
            const canGoNext = currentPageIndex < PAGES.length - 1;

            if (currentPageIndex === 0) return null;
            
            return (
                <footer className="bg-white border-t border-gray-200 sticky bottom-0 z-10 shadow-inner">
                    <div className="container mx-auto px-4 sm:px-8 py-4 max-w-5xl flex justify-between items-center">
                        <button
                            onClick={onBack}
                            disabled={!canGoBack}
                            className={`font-medium py-2 px-6 rounded-full transition duration-300 ${
                                canGoBack
                                    ? 'bg-gray-200 hover:bg-gray-300 text-gray-700'
                                    : 'bg-gray-100 text-gray-400 cursor-not-allowed'
                            }`}
                        >
                            Terug
                        </button>
                        <div className="text-sm text-gray-500">
                            Pagina {currentPageIndex} van {PAGES.length - 1}
                        </div>
                        {canGoNext && (
                            <button
                                onClick={onNext}
                                disabled={!canGoNext}
                                className={`font-bold py-2 px-6 rounded-full transition duration-300 ${
                                    canGoNext
                                        ? 'bg-blue-600 hover:bg-blue-700 text-white'
                                        : 'bg-blue-300 text-white cursor-not-allowed'
                                }`}
                            >
                                Volgende
                            </button>
                        )}
                    </div>
                </footer>
            );
        };

        function App() {
            const [currentPageIndex, setCurrentPageIndex] = useState(0);
            
            const getInitialSelections = () => ({
                viral: null, 
                ceo: null,   
                troublemaker: null 
            });
            
            const getInitialTraits = () => ({
                viral: [], 
                ceo: [],   
                troublemaker: [] 
            });

            const [selections, setSelections] = useState(getInitialSelections());
            const [assignedTraits, setAssignedTraits] =useState(getInitialTraits());

            useEffect(() => {
                window.scrollTo(0, 0);
            }, [currentPageIndex]);

            const onNext = (pageIndex) => {
                if (typeof pageIndex === 'number') {
                    if (pageIndex === 0) {
                        setSelections(getInitialSelections());
                        setAssignedTraits(getInitialTraits());
                    }
                    setCurrentPageIndex(pageIndex);
                } else if (currentPageIndex < PAGES.length - 1) {
                    setCurrentPageIndex(currentPageIndex + 1);
                }
            };
            
            const renderPage = () => {
                const pageName = PAGES[currentPageIndex];

                switch (pageName) {
                    case 'home':
                        return <HomePage onNext={onNext} />;
                    case 'objectives':
                        return <ObjectivesPage onNext={onNext} />;
                    case 'introduction':
                        return <IntroductionPage onNext={onNext} />;
                    case 'meet-the-class':
                        return <MeetTheClassPage onNext={onNext} />;
                    case 'predict-winners':
                        return <PredictWinnersPage onNext={onNext} selections={selections} setSelections={setSelections} />;
                    case 'create-algorithm':
                        return <CreateAlgorithmPage onNext={onNext} assignedTraits={assignedTraits} setAssignedTraits={setAssignedTraits} />;
                    case 'tune-algorithm':
                        return <TuneAlgorithmPage onNext={onNext} assignedTraits={assignedTraits} setAssignedTraits={setAssignedTraits} />;
                    case 'results':
                        return <ResultsPage onNext={onNext} selections={selections} assignedTraits={assignedTraits} />;
                    case 'reflection':
                        return <ReflectionPage onNext={onNext} />;
                    case 'recap':
                        return <RecapPage onNext={onNext} />;
                    default:
                        return <HomePage onNext={onNext} />;
                }
            };
            
            const pageTitle = PAGES[currentPageIndex] ? PAGES[currentPageIndex].replace(/-/g, ' ') : '';
            const titleCasePageTitle = pageTitle.charAt(0).toUpperCase() + pageTitle.slice(1);

            return (
                <div className="min-h-screen bg-gray-50 font-sans flex flex-col">
                    <header className="bg-white shadow-sm sticky top-0 z-10">
                    </header>

                    <main className="flex-grow">
                        {renderPage()}
                    </main>

                    <Navigation
                        currentPageIndex={currentPageIndex}
                        setCurrentPage={setCurrentPageIndex}
                    />
                </div>
            );
        }

        // App renderen in de root div
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
