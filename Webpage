import React, { useState, useEffect } from 'react';

// --- Data ---
// Mock data for the "Meet the Class" section
const mockStudents = [
  { id: 1, name: 'Sophie V.' },
  { id: 2, name: 'Franky D.' },
  { id: 3, name: 'Pascale D.' },
  { id: 4, name: 'Daphné V.' },
  { id: 5, name: 'Déborah P.' },
  { id: 6, name: 'Elke W.' },
  { id: 7, name: 'Freya S.' },
  { id: 8, name: 'Bryan F.' }, // [AANGEPAST] Naam gewijzigd
  { id: 9, name: 'Febe V.' },
];

// --- [NIEUW] Afbeeldingslinks voor studenten (bijgewerkt) ---
const studentImages = {
  1: 'images/1SophieV',
  2: 'images/1FrankyD',
  3: 'images/1PascaleD',
  4: 'images/1DaphneV',
  5: 'images/1DeborahP',
  6: 'images/1ElkeW',
  7: 'images/1FreyaS',
  8: 'images/1BryanF',   // Gekoppeld aan Bryan F. (id 8)
  9: 'images/1FebeV',    // Gekoppeld aan Febe V. (id 9)
};


// --- Trait Card Data (Total 27 for 9 per award) ---
const mockTraitCardsData = [
  { id: 1, name: 'Aanpasbaar' },
  { id: 2, name: 'Avontuurlijk' },
  { id: 3, name: 'Agressief' },
  { id: 4, name: 'Athletisch' },
  { id: 5, name: 'Moedig' },
  { id: 6, name: 'Berekend' },
  { id: 7, name: 'Meeslepend' },
  { id: 8, name: 'Geëngageerd' },
  { id: 9, name: 'Creatief' },
  { id: 10, name: 'Roekeloos' },
  { id: 11, name: 'Toegewijd' },
  { id: 12, name: 'Uitdagend' },
  { id: 13, name: 'Vastberaden' },
  { id: 14, name: 'Gedisciplineerd' },
  { id: 15, name: 'Gedreven' },
  { id: 16, name: 'Grappig' },
  { id: 17, name: 'Onafhankelijk' },
  { id: 18, name: 'Invloedrijk' },
  { id: 19, name: 'Meertalig' },
  { id: 20, name: 'Muzikaal' },
  { id: 21, name: 'Speels' },
  { id: 22, name: 'Rebels' },
  { id: 23, name: 'Onvermoeibaar' },
  { id: 24, name: 'Theatraal' },
  { id: 25, name: 'Taai' },
  { id: 26, name: 'Baanbrekend' },
  { id: 27, name: 'Wraakzuchtig' },
];

// --- [NIEUW] Afbeeldingslinks voor kenmerken (bijgewerkt) ---
const traitImages = {
  1: 'images/Aanpasbaar',
  2: 'images/Avontuurlijk',
  3: 'images/Agressief',
  4: 'images/Athletisch',
  5: 'images/Moedig',
  6: 'images/Berekend',
  7: 'images/Meeslepend',
  8: 'images/Geëngageerd',
  9: 'images/Creatief',
  10: 'images/Roekeloos',
  11: 'images/Toegewijd',
  12: 'images/Uitdagend',
  13: 'images/Vastberaden',
  14: 'images/Gedisciplineerd',
  15: 'images/Gedreven',
  16: 'images/Grappig',
  17: 'images/Onafhankelijk',
  18: 'images/Invloedrijk',
  19: 'images/Meertalig',
  20: 'images/Muzikaal',
  21: 'images/Speels',
  22: 'images/Rebels',
  23: 'images/Onvermoeibaar',
  24: 'images/Theatraal',
  25: 'images/Taai',
  26: 'images/Baanbrekend',
  27: 'images/Wraakzuchtig',
};


// --- Trait Name Lookup Map ---
const traitNameMap = Object.fromEntries(mockTraitCardsData.map(trait => [trait.id, trait.name]));

// --- Student Scorecards (Scores 1-20 for each trait for 9 students) ---
const studentScorecards = {
  // studentId: { traitId: score, ... }
  1: { 1: 4, 2: 15, 3: 9, 4: 1, 5: 11, 6: 19, 7: 7, 8: 14, 9: 3, 10: 17, 11: 20, 12: 6, 13: 13, 14: 10, 15: 18, 16: 5, 17: 12, 18: 2, 19: 16, 20: 8, 21: 1, 22: 19, 23: 14, 24: 7, 25: 11, 26: 20, 27: 5 },
  2: { 1: 18, 2: 10, 3: 3, 4: 14, 5: 8, 6: 17, 7: 2, 8: 12, 9: 19, 10: 5, 11: 16, 12: 1, 13: 11, 14: 20, 15: 7, 16: 15, 17: 4, 18: 9, 19: 13, 20: 6, 21: 18, 22: 2, 23: 10, 24: 17, 25: 1, 26: 14, 27: 8 },
  3: { 1: 6, 2: 1, 3: 16, 4: 11, 5: 19, 6: 4, 7: 13, 8: 20, 9: 8, 10: 15, 11: 2, 12: 10, 13: 18, 14: 5, 15: 12, 16: 17, 17: 7, 18: 14, 19: 1, 20: 9, 21: 16, 22: 3, 23: 11, 24: 20, 25: 6, 26: 13, 27: 18 },
  4: { 1: 10, 2: 19, 3: 5, 4: 12, 5: 3, 6: 17, 7: 9, 8: 1, 9: 15, 10: 7, 11: 14, 12: 20, 13: 4, 14: 11, 15: 18, 16: 6, 17: 13, 18: 2, 19: 17, 20: 9, 21: 16, 22: 1, 23: 12, 24: 5, 25: 20, 26: 8, 27: 15 },
  5: { 1: 1, 2: 13, 3: 18, 4: 7, 5: 15, 6: 2, 7: 10, 8: 17, 9: 5, 10: 12, 11: 20, 12: 8, 13: 16, 14: 3, 15: 11, 16: 19, 17: 6, 18: 14, 19: 1, 20: 10, 21: 17, 22: 4, 23: 19, 24: 9, 25: 15, 26: 7, 27: 2 },
  6: { 1: 12, 2: 7, 3: 1, 4: 16, 5: 11, 6: 9, 7: 18, 8: 4, 9: 14, 10: 20, 11: 3, 12: 10, 13: 17, 14: 8, 15: 15, 16: 2, 17: 13, 18: 19, 19: 6, 20: 11, 21: 1, 22: 18, 23: 5, 24: 16, 25: 10, 26: 14, 27: 7 },
  7: { 1: 16, 2: 3, 3: 11, 4: 19, 5: 8, 6: 1, 7: 14, 8: 20, 9: 6, 10: 13, 11: 2, 12: 10, 13: 17, 14: 5, 15: 12, 16: 18, 17: 9, 18: 15, 19: 4, 20: 1, 21: 11, 22: 20, 23: 7, 24: 14, 25: 2, 26: 18, 27: 8 },
  8: { 1: 9, 2: 20, 3: 7, 4: 13, 5: 2, 6: 11, 7: 18, 8: 5, 9: 16, 10: 1, 11: 10, 12: 19, 13: 3, 14: 15, 15: 8, 16: 12, 17: 17, 18: 6, 19: 14, 20: 20, 21: 4, 22: 9, 23: 1, 24: 11, 25: 18, 26: 7, 27: 13 },
  9: { 1: 3, 2: 11, 3: 17, 4: 9, 5: 14, 6: 20, 7: 6, 8: 12, 9: 1, 10: 19, 11: 8, 12: 16, 13: 5, 14: 13, 15: 2, 16: 18, 17: 10, 18: 15, 19: 7, 20: 14, 21: 20, 22: 4, 23: 9, 24: 17, 25: 1, 26: 12, 27: 6 },
};


// --- PAGES array ---
const PAGES = [
  'home',
  'objectives',
  'introduction',
  'meet-the-class',
  'predict-winners',
  'create-algorithm',
  'tune-algorithm',
  'results',
  'reflection',
  'recap',
];

const MAX_TRAITS_PER_AWARD = 9;

// --- [TRANSLATED & UPDATED] ---
const awardsConfig = {
  viral: "Meest waarschijnlijk... Viraal te gaan",
  ceo: "Meest waarschijnlijk... CEO te worden",
  troublemaker: "Meest waarschijnlijk... Een marathon te lopen"
};

// --- Helper Function for Score Calculation ---
/**
 * Calculates scores for all students for a specific award.
 * @param {string} awardKey - The key of the award (e.g., 'viral').
 * @param {object} assignedTraits - The state object mapping award keys to trait arrays.
 * @returns {Array} A sorted list of student objects, each with a new 'score' property.
 */
const calculateScores = (awardKey, assignedTraits) => {
  const prioritizedTraits = assignedTraits[awardKey];
  
  if (!prioritizedTraits || prioritizedTraits.length === 0) {
    return mockStudents.map(student => ({ ...student, score: 0 }));
  }

  // Create a weight map (9 for 1st, 8 for 2nd, ...)
  const traitWeights = {};
  prioritizedTraits.forEach((trait, index) => {
    const weight = MAX_TRAITS_PER_AWARD - index; // 9, 8, 7...
    traitWeights[trait.id] = weight;
  });

  const scoredStudents = mockStudents.map(student => {
    let totalScore = 0;
    const studentScores = studentScorecards[student.id]; // Get this student's scores

    // Calculate score based on the prioritized traits
    prioritizedTraits.forEach(trait => {
      const traitId = trait.id;
      const weight = traitWeights[traitId];
      const studentBaseScore = studentScores[traitId] || 0; // Score from 1-20
      
      totalScore += (studentBaseScore * weight);
    });
    
    return { ...student, score: totalScore };
  });

  // Sort students by score, descending
  return scoredStudents.sort((a, b) => b.score - a.score);
};


// --- Page Components ---

const PageContainer = ({ children, title }) => (
  <div className="flex-grow container mx-auto px-4 sm:px-8 py-12 max-w-5xl">
    <h1 className="text-3xl sm:text-4xl font-bold text-gray-800 mb-8 text-center">{title}</h1>
    {children}
  </div>
);

// --- [TRANSLATED & UPDATED with image] ---
const HomePage = ({ onNext }) => (
  <PageContainer title="De 'most likely' machine">
    <div className="text-center">
      <h3 className="text-2xl font-semibold text-gray-700 mb-4">
        Word wijzer over algoritmen
      </h3>
      <p className="text-xl text-gray-600 mb-12 max-w-2xl mx-auto">
        Algoritmen drijven de wereld aan, maar ze kunnen fouten maken. Bouw je eigen algoritme en zie welke impact het heeft - ten goede en ten kwade.
      </p>
      <div className="w-full max-w-md h-64 bg-gray-300 rounded-lg mx-auto mb-12 shadow-lg overflow-hidden">
        <img
          src="https.images.unsplash.com/photo-1664448288134-669f14c3ebbb?q=80&w=2080&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
          alt="Abstract algorithmic art"
          className="w-full h-full object-cover"
          onError={(e) => { e.target.src = 'https://placehold.co/600x400/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
        />
      </div>
      <button
        onClick={onNext}
        className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full text-lg transition duration-300 shadow-md hover:shadow-lg"
      >
        Start
      </button>
    </div>
  </PageContainer>
);

// --- [TRANSLATED & UPDATED with images] ---
const ObjectivesPage = ({ onNext }) => (
  <PageContainer title="Kom meer te weten over...">
    <div className="max-w-2xl mx-auto bg-white p-8 rounded-lg shadow-xl space-y-10">
      
      <div className="text-center">
        <div className="w-full max-w-xs h-48 bg-gray-300 rounded-lg mx-auto mb-4 shadow-md flex items-center justify-center overflow-hidden">
          <img
            src="images/2What" // [AANGEPAST] .webp verwijderd
            alt="What"
            className="w-full h-full object-cover"
            onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
          />
        </div>
        <h2 className="text-2xl font-semibold text-gray-800">Wat zijn algoritmes?</h2>
      </div>

      <div className="text-center">
        <div className="w-full max-w-xs h-48 bg-gray-300 rounded-lg mx-auto mb-4 shadow-md flex items-center justify-center overflow-hidden">
          <img
            src="images/2Used" // [AANGEPAST] .webp verwijderd
            alt="Used"
            className="w-full h-full object-cover"
            onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
          />
        </div>
        <h2 className="text-2xl font-semibold text-gray-800">Waarvoor worden ze gebruikt?</h2>
      </div>

      <div className="text-center">
        <div className="w-full max-w-xs h-48 bg-gray-300 rounded-lg mx-auto mb-4 shadow-md flex items-center justify-center overflow-hidden">
          <img
            src="images/2Bias" // Was al correct
            alt="Bias"
            className="w-full h-full object-cover"
            onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
          />
        </div>
        <h2 className="text-2xl font-semibold text-gray-800">Wat is algoritmische bias?</h2>
      </div>

      <div className="text-center">
        <div className="w-full max-w-xs h-48 bg-gray-300 rounded-lg mx-auto mb-4 shadow-md flex items-center justify-center overflow-hidden">
          <img
            src="images/2Why" // [AANGEPAST] .webp verwijderd
            alt="Why"
            className="w-full h-full object-cover"
            onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
          />
        </div>
        <h2 className="text-2xl font-semibold text-gray-800">Waarom is het belangrijk?</h2>
      </div>

    </div>
  </PageContainer>
);

// --- [TRANSLATED & UPDATED] ---
const IntroductionPage = ({ onNext }) => (
  <PageContainer title="Opdracht">
    <div className="max-w-3xl mx-auto space-y-6 text-lg text-gray-700">
      <p>
        Dit jaar delen we bij AGO de "most likely..."-awards uit.
      </p>
      <div className="w-full h-56 bg-gray-300 rounded-lg shadow-md flex items-center justify-center">
        <span className="text-gray-500">Afbeelding Plaatshouder</span>
      </div>
      <p>
        Maar wat als deze voorspellingen door een machine werden gedaan?
      </p>
      <p>
        Jij zal beslissen over drie prijzen: "Meest waarschijnlijk... Viraal te gaan", "Meest waarschijnlijk... CEO te worden" en "Meest waarschijnlijk... Een marathon te lopen." Eerst gebruik je je intuïtie. Daarna ontwerp je algoritmen om het werk voor je te doen.
      </p>
    </div>
  </PageContainer>
);

// --- [TRANSLATED & UPDATED with images] ---
const StudentCard = ({ student }) => {
  // Get the student's scores
  const scores = studentScorecards[student.id];
  
  // Find top 3 traits
  const topTraits = Object.entries(scores) // [ ['1', 19], ['2', 12], ... ]
    .sort(([, scoreA], [, scoreB]) => scoreB - scoreA) // Sort by score descending
    .slice(0, 3) // Get top 3
    .map(([traitId, score]) => ({
      name: traitNameMap[traitId], // Use global map
      score: score,
    }));

  return (
    <div
      className="bg-white rounded-lg shadow-lg p-4 relative transition-all duration-300 flex flex-col"
    >
      <img
        src={studentImages[student.id]}
        alt={student.name}
        className="w-full h-40 object-cover rounded-md mb-4" // H-40 toegevoegd
        onError={(e) => { e.target.src = 'https://placehold.co/400x300/e2e8f0/64748b?text=Beeld+niet+gevonden'; e.target.onerror = null; }}
      />
      <h3 className="font-bold text-lg text-gray-800 mb-2">{student.name}</h3>
      <div className="flex-grow">
        <h4 className="font-semibold text-sm text-gray-500 mb-2">Topkenmerken:</h4>
        <ul className="text-sm text-gray-600 space-y-1">
          {topTraits.map((trait, index) => (
            <li key={trait.name} className="flex justify-between">
              <span>{trait.name}</span>
              <span className="font-bold text-blue-600">{trait.score} / 20</span>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

// --- [TRANSLATED & UPDATED] ---
const MeetTheClassPage = ({ onNext }) => (
  <PageContainer title="Maak kennis met de finalisten">
    <p className="text-center text-lg text-gray-600 mb-8 max-w-2xl mx-auto">
      Je zit in het prijzencomité. Jouw taak is om de "Most likely..."-awards van dit jaar uit te reiken. Maak hieronder kennis met de 9 finalisten voordat je stemt.
    </p>
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 gap-6">
      {mockStudents.map(student => (
        <StudentCard key={student.id} student={student} />
      ))}
    </div>
  </PageContainer>
);

// --- Award Selector Component (for Page 5) ---
// --- [TRANSLATED & UPDATED with images] ---
const AwardSelector = ({ awardKey, awardLabel, selectedId, setSelections }) => {
  const handleSelect = (e) => {
    const studentId = e.target.value ? parseInt(e.target.value, 10) : null;
    setSelections(prev => ({
      ...prev,
      [awardKey]: studentId
    }));
  };

  const selectedStudent = selectedId ? mockStudents.find(s => s.id === selectedId) : null;

  return (
    <div className="bg-white p-6 rounded-lg shadow-xl mb-8">
      <label className="block text-xl font-semibold text-gray-800 mb-4" htmlFor={`select-${awardKey}`}>
        {awardLabel}
      </label>
      <select
        id={`select-${awardKey}`}
        value={selectedId || ''}
        onChange={handleSelect}
        className="w-full p-3 border border-gray-300 rounded-lg text-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
      >
        <option value="">Selecteer een kandidaat...</option> {/* [AANGEPAST] */}
        {mockStudents.map(student => (
          <option key={student.id} value={student.id}>
            {student.name}
          </option>
        ))}
      </select>

      {selectedStudent && (
        <div className="mt-6 p-4 bg-gray-100 rounded-lg flex items-center space-x-4">
          <img
            src={studentImages[selectedStudent.id]}
            alt={selectedStudent.name}
            className="w-20 h-20 object-cover rounded-md"
            onError={(e) => { e.target.src = 'https://placehold.co/100x100/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
          />
          <div>
            <h4 className="font-bold text-lg text-gray-800">{selectedStudent.name}</h4>
            <p className="text-gray-600">Jouw intuïtieve keuze</p>
          </div>
        </div>
      )}
    </div>
  );
};

// --- Predict Winners Page (Page 5) ---
// --- [TRANSLATED & UPDATED] ---
const PredictWinnersPage = ({ onNext, selections, setSelections }) => {
  return (
    <PageContainer title="Voorspel de winnaars">
      <p className="text-center text-lg text-gray-600 mb-8 max-w-2xl mx-auto">
        Selecteer op basis van je intuïtie één winnaar voor elke prijs met behulp van de dropdownmenu's hieronder.
      </p>
      
      <div className="max-w-2xl mx-auto">
        {Object.keys(awardsConfig).map(key => (
          <AwardSelector
            key={key}
            awardKey={key}
            awardLabel={awardsConfig[key]}
            selectedId={selections[key]}
            setSelections={setSelections}
          />
        ))}
      </div>
    </PageContainer>
  );
};


// --- Draggable Trait Card (for Page 6) ---
// --- [BIJGEWERKT met afbeeldingen] ---
const AlgorithmTraitCard = ({ trait, onDragStart, isDraggable }) => (
  <div
    draggable={isDraggable}
    onDragStart={isDraggable ? onDragStart : null}
    className={`w-64 h-32 rounded-lg shadow-xl overflow-hidden relative group ${isDraggable ? 'cursor-grab active:cursor-grabbing' : 'opacity-50 cursor-not-allowed'}`}
  >
    <img
      src={traitImages[trait.id]}
      alt={trait.name}
      className="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
      onError={(e) => { e.target.src = 'https://placehold.co/256x128/e2e8f0/64748b?text=Beeld'; e.target.onerror = null; }}
    />
    <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <h3 className="font-bold text-xl text-white text-center p-2" style={{ textShadow: '1px 1px 2px rgba(0,0,0,0.7)' }}>
        {trait.name}
      </h3>
    </div>
    {!isDraggable && (
      <div className="absolute inset-0 bg-gray-500 bg-opacity-50" />
    )}
  </div>
);


// --- Drop Zone for Awards (for Page 6) ---
// --- [TRANSLATED] ---
const AwardTraitDropZone = ({ awardKey, awardLabel, onDrop, onDragOver, children, isDragOver, traitCount, maxTraits }) => {
  const isFull = traitCount >= maxTraits;
  return (
    <div
      onDrop={onDrop}
      onDragOver={onDragOver}
      data-award-key={awardKey}
      className={`w-full md:w-1/3 bg-gray-100 p-4 rounded-lg shadow-inner min-h-[10rem] transition-colors ${
        isDragOver && !isFull ? 'bg-blue-100 ring-2 ring-blue-500' : ''
      } ${isFull ? 'bg-green-50 border-2 border-green-300' : 'border-2 border-transparent'}`}
    >
      <h3 className="text-xl font-semibold text-gray-800 text-center mb-2">{awardLabel}</h3>
      <div className="text-center font-medium text-gray-600 mb-4">
        {traitCount} / {maxTraits} kenmerken
      </div>
      <div className="space-y-2 flex flex-wrap gap-2 justify-center">
        {children}
      </div>
      {isFull && (
        <div className="text-center text-green-700 font-semibold mt-4">
          Voltooid!
        </div>
      )}
    </div>
  );
};

// --- Assigned Trait Pill ---
const AssignedTraitPill = ({ trait }) => (
  <div className="bg-white py-1 px-3 rounded-full shadow-md">
    <span className="font-medium text-sm text-gray-700">{trait.name}</span>
  </div>
);

// --- Create Algorithm Page (Page 6) ---
// --- [TRANSLATED & UPDATED] ---
const CreateAlgorithmPage = ({ onNext, assignedTraits, setAssignedTraits }) => {
  // Student stack state
  const [draggedTrait, setDraggedTrait] = useState(null);
  const [dragOverZone, setDragOverZone] = useState(null);

  // [CODE REVIEW FIX]
  // Initialize 'remainingTraits' based on the 'assignedTraits' prop.
  // This ensures that if the user navigates back to this page, their
  // previous selections are respected and the stack is correctly filtered.
  const [remainingTraits, setRemainingTraits] = useState(() => {
    // 1. Get all IDs that are *already* assigned
    const assignedIds = new Set([
      ...assignedTraits.viral.map(t => t.id),
      ...assignedTraits.ceo.map(t => t.id),
      ...assignedTraits.troublemaker.map(t => t.id),
    ]);

    // 2. Filter the master list, keeping only traits NOT in the set
    return mockTraitCardsData
      .filter(trait => !assignedIds.has(trait.id))
      .reverse(); // Reverse for the stack 'pop'
  });

  const currentTrait = remainingTraits.length > 0 ? remainingTraits[remainingTraits.length - 1] : null;

  const handleDragStart = (trait) => (e) => {
    e.dataTransfer.setData("traitId", trait.id);
    setDraggedTrait(trait);
  };
  
  const handleDragOver = (e) => {
    e.preventDefault();  
    const targetZone = e.currentTarget.dataset.awardKey;
    if (targetZone) {
      if (assignedTraits[targetZone].length < MAX_TRAITS_PER_AWARD) {
        setDragOverZone(targetZone);
      } else {
        setDragOverZone(null);  
      }
    }
  };

  const handleDragLeave = () => {
    setDragOverZone(null);
  };

  const handleDrop = (e) => {
    e.preventDefault();
    setDragOverZone(null);  
    const traitId = parseInt(e.dataTransfer.getData("traitId"), 10);
    const awardKey = e.currentTarget.dataset.awardKey;

    if (!traitId || !awardKey || !draggedTrait) return;

    if (assignedTraits[awardKey].length >= MAX_TRAITS_PER_AWARD) {
      setDraggedTrait(null);
      return;  
    }

    if (currentTrait && traitId === currentTrait.id) {
      setAssignedTraits(prev => ({
        ...prev,
        [awardKey]: [...prev[awardKey], draggedTrait]
      }));
      setRemainingTraits(prev => prev.slice(0, -1));
    }
    
    setDraggedTrait(null);
  };
  
  const handleDragEnd = () => {
    setDraggedTrait(null);
    setDragOverZone(null);
  };

  return (
    <PageContainer title="Creëer het algoritme">
      <p className="text-center text-lg text-gray-600 mb-8 max-w-2xl mx-auto">
        Nu gaan we jouw "algoritme" bouwen. Sleep elk kenmerk van de stapel en laat het vallen op de prijs waarvoor je denkt dat het het meest relevant is. Elke prijs heeft {MAX_TRAITS_PER_AWARD} kenmerken nodig.
      </p>

      {/* Card Stack */}
      <div className="h-48 flex items-center justify-center relative mb-8">
        {remainingTraits.length > 0 ? (
          remainingTraits.map((trait, index) => {
            const isTopCard = index === remainingTraits.length - 1;
            return (
              <div
                key={trait.id}
                className="absolute transition-all"
                style={{
                  transform: `translate(${index * -2}px, ${index * -2}px)`,
                  zIndex: index,
                  opacity: isTopCard ? 1 : (1 - (remainingTraits.length - index) * 0.1),
                  filter: isTopCard ? 'none' : 'blur(2px)'
                }}
              >
                <AlgorithmTraitCard
                  trait={trait}
                  onDragStart={handleDragStart(trait)}
                  isDraggable={isTopCard}
                />
              </div>
            );
          })
        ) : (
          <p className="text-xl text-gray-500">Alle kenmerken toegewezen! Ga naar de volgende pagina om je algoritme te verfijnen.</p>
        )}
      </div>

      {/* Drop Zones */}
      <div 
        className="flex flex-col md:flex-row gap-6"
        onDragLeave={handleDragLeave}
        onDragEnd={handleDragEnd}
      >
        {Object.keys(awardsConfig).map(key => (
          <AwardTraitDropZone
            key={key}
            awardKey={key}
            awardLabel={awardsConfig[key]}
            onDrop={handleDrop}
            onDragOver={handleDragOver}
            isDragOver={dragOverZone === key}
            traitCount={assignedTraits[key].length}
            maxTraits={MAX_TRAITS_PER_AWARD}
          >
            {assignedTraits[key].map(trait => (
              <AssignedTraitPill key={trait.id} trait={trait} />
            ))}
          </AwardTraitDropZone>
        ))}
      </div>
    </PageContainer>
  );
};

// --- Draggable Trait Item for Page 7 ---
// --- [VERBETERD] Gebruikt nu randen i.p.v. layout-verschuivende indicator ---
const DraggableTraitItem = ({ trait, onDragStart, onDragOver, onDrop, onDragEnd, isDragging, isDropTargetBefore, isDropTargetAfter }) => (
  <div
    draggable
    onDragStart={onDragStart}
    onDragOver={onDragOver}
    onDrop={onDrop}
    onDragEnd={onDragEnd}
    data-trait-id={trait.id} // Set trait id data attribute for drop target identification
    className={`p-4 bg-white rounded-lg shadow-md flex items-center justify-between cursor-grab active:cursor-grabbing transition-colors duration-100 ease-in-out
      ${isDragging ? 'opacity-50' : 'opacity-100'}
      border-t-8 border-b-8
      ${isDropTargetBefore ? 'border-t-blue-500' : 'border-t-transparent'}
      ${isDropTargetAfter ? 'border-b-blue-500' : 'border-b-transparent'}
      ${!isDropTargetBefore && !isDropTargetAfter ? 'border-y-transparent' : ''}
    `}
  >
    <span className="font-medium text-gray-700">{trait.name}</span>
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16m-7 6h7" />
    </svg>
  </div>
);

// --- [VERWIJDERD] Drop Indicator Component ---

// --- Tune Algorithm Page (Page 7) ---
// --- [VERBETERD met anti-flicker drop-indicator] ---
const TuneAlgorithmPage = ({ onNext, assignedTraits, setAssignedTraits }) => {
  const [selectedAward, setSelectedAward] = useState(Object.keys(awardsConfig)[0]);  
  const [draggedTraitId, setDraggedTraitId] = useState(null);
  const [dropIndicator, setDropIndicator] = useState({ targetId: null, position: 'before' });

  const handleDragStart = (e) => {
    const traitId = parseInt(e.currentTarget.dataset.traitId, 10);
    setDraggedTraitId(traitId);
    e.dataTransfer.setData("traitId", traitId);
    e.dataTransfer.effectAllowed = "move";
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    const targetElement = e.currentTarget;
    const targetTraitId = parseInt(targetElement.dataset.traitId, 10);
    
    if (!targetTraitId || targetTraitId === draggedTraitId) return;

    const rect = targetElement.getBoundingClientRect();
    const midY = rect.top + rect.height / 2;
    const position = e.clientY < midY ? 'before' : 'after';

    if (dropIndicator.targetId !== targetTraitId || dropIndicator.position !== position) {
      setDropIndicator({ targetId: targetTraitId, position });
    }
  };

  const handleDragLeaveContainer = () => {
    setDropIndicator({ targetId: null, position: 'before' });
  };

  const handleDrop = (e) => {
    e.preventDefault();
    
    if (!dropIndicator.targetId || !draggedTraitId || dropIndicator.targetId === draggedTraitId) {
      setDraggedTraitId(null);
      setDropIndicator({ targetId: null, position: 'before' });
      return;
    }

    const currentTraits = [...assignedTraits[selectedAward]];
    
    const draggedIndex = currentTraits.findIndex(t => t.id === draggedTraitId);
    if (draggedIndex === -1) {
        setDraggedTraitId(null);
        setDropIndicator({ targetId: null, position: 'before' });
        return;
    }
    const draggedItem = currentTraits.splice(draggedIndex, 1)[0];
    
    if (!draggedItem) {
      setDraggedTraitId(null);
      setDropIndicator({ targetId: null, position: 'before' });
      return;
    }

    let targetIndex = currentTraits.findIndex(t => t.id === dropIndicator.targetId);

    if (dropIndicator.position === 'after') {
      targetIndex++;
    }
    
    currentTraits.splice(targetIndex, 0, draggedItem);

    setAssignedTraits(prev => ({
      ...prev,
      [selectedAward]: currentTraits
    }));
    
    setDraggedTraitId(null);
    setDropIndicator({ targetId: null, position: 'before' });
  };

  const handleDragEnd = () => {
    setDraggedTraitId(null);
    setDropIndicator({ targetId: null, position: 'before' });
  };

  const currentTraits = assignedTraits[selectedAward];

  return (
    <PageContainer title="Verfijn het algoritme">
      <p className="text-center text-lg text-gray-600 mb-8 max-w-2xl mx-auto">
        Geef nu prioriteit aan de kenmerken voor elk algoritme. Klik op een prijs en sleep de kenmerken om ze opnieuw te ordenen van meest belangrijk (boven) naar minst belangrijk (onder).
      </p>

      {/* Award Selector Tabs */}
      <div className="flex justify-center gap-4 mb-8">
        {Object.keys(awardsConfig).map(key => (
          <button
            key={key}
            onClick={() => setSelectedAward(key)}
            className={`py-3 px-6 rounded-full font-semibold transition-all ${
              selectedAward === key
                ? 'bg-blue-600 text-white shadow-lg'
                : 'bg-white text-gray-700 shadow-md hover:bg-gray-100'
            }`}
          >
            {awardsConfig[key]}
          </button>
        ))}
      </div>

      {/* Draggable Trait List */}
      <div className="max-w-md mx-auto bg-gray-100 p-6 rounded-lg shadow-inner">
        <h3 className="text-xl font-semibold text-gray-800 mb-4 text-center">{awardsConfig[selectedAward]}</h3>
        {currentTraits.length > 0 ? (
          <div className="space-y-0" onDragEnd={handleDragEnd} onDragLeave={handleDragLeaveContainer}> {/* space-y-0 i.p.v. space-y-3 */}
            {currentTraits.map((trait, index) => (
              <DraggableTraitItem
                key={trait.id}
                trait={trait}
                isDragging={draggedTraitId === trait.id}
                onDragStart={handleDragStart}
                onDragOver={handleDragOver}
                onDrop={handleDrop}
                onDragEnd={handleDragEnd}
                isDropTargetBefore={dropIndicator.targetId === trait.id && dropIndicator.position === 'before'}
                isDropTargetAfter={dropIndicator.targetId === trait.id && dropIndicator.position === 'after'}
              />
            ))}
          </div>
        ) : (
          <p className="text-gray-500 text-center italic py-4">
            Geen kenmerken toegewezen aan deze prijs. Ga terug naar "Creëer Je Algoritmen" om ze toe te voegen.
          </p>
        )}
      </div>
    </PageContainer>
  );
};


// --- Results Modal Component ---
// --- [TRANSLATED] ---
const ResultsModal = ({ modalData, onClose }) => {
  if (!modalData) return null;

  const { awardKey, leaderboard, traits } = modalData;
  const winner = leaderboard[0];
  const runnersUp = leaderboard.slice(1, 4);

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
      onClick={onClose} // Close on overlay click
    >
      <div
        className="bg-white rounded-lg shadow-2xl p-6 sm:p-8 max-w-2xl w-full max-h-[90vh] overflow-y-auto"
        onClick={(e) => e.stopPropagation()} // Prevent closing when clicking modal content
      >
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-2xl sm:text-3xl font-bold text-gray-800">{awardsConfig[awardKey]}</h2>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 transition-colors"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Leaderboard */}
        <div className="mb-8">
          <h3 className="text-xl font-semibold text-gray-700 mb-4">Eindklassement</h3>
          <ol className="space-y-3">
            {/* Winner */}
            <li className="flex items-center justify-between bg-yellow-100 p-4 rounded-lg shadow-md">
              <span className="text-lg font-bold text-yellow-800">1. {winner.name}</span>
              <span className="text-lg font-bold text-yellow-800">{winner.score.toLocaleString()} pnt</span>
            </li>
            {/* Runners-up */}
            {runnersUp.map((student, index) => (
              <li key={student.id} className="flex items-center justify-between bg-gray-100 p-3 rounded-md">
                <span className="text-base font-medium text-gray-700">{index + 2}. {student.name}</span>
                <span className="text-base font-medium text-gray-600">{student.score.toLocaleString()} pnt</span>
              </li>
            ))}
          </ol>
        </div>

        {/* Why did they win? */}
        <div>
          <h3 className="text-xl font-semibold text-gray-700 mb-4">Waarom heeft {winner.name} gewonnen?</h3>
          <p className="text-gray-600 text-base mb-6">
            Toen je het algoritme ontwierp, heb je het geleerd om 9 persoonlijkheidskenmerken te herkennen als de beste voor deze prijs. Je hebt er ook één als belangrijkste gerangschikt, wat betekent dat het 9 punten waard is, waarbij elk volgend kenmerk in punten afneemt.
          </p>
          <div className="bg-gray-50 p-4 rounded-lg border">
            <h4 className="text-base font-semibold text-gray-700 mb-3">Jouw Kenmerk-rangschikking & Punten</h4>
            <ul className="space-y-2">
              {traits.map((trait, index) => (
                <li key={trait.id} className="flex justify-between items-center text-sm">
                  <span className="font-medium text-gray-600">{trait.name}</span>
                  <span className="font-bold text-blue-600">{MAX_TRAITS_PER_AWARD - index} pnt</span>
                </li>
              ))}
            </ul>
          </div>
        </div>

        <button
          onClick={onClose}
          className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300 shadow-md hover:shadow-lg mt-8"
        >
          Sluiten
        </button>
      </div>
    </div>
  );
};


// --- Results Page (Page 8) ---
// --- [TRANSLATED & UPDATED] ---
const ResultsPage = ({ onNext, selections, assignedTraits }) => {
  const [algorithmPicks, setAlgorithmPicks] = useState({
    viral: null,
    ceo: null,
    troublemaker: null
  });
  
  // State for the modal
  const [modalData, setModalData] = useState(null); // e.g., { awardKey, leaderboard, traits }

  // Calculate results when component mounts or data changes
  useEffect(() => {
    const calculateResults = () => {
      const picks = {};

      Object.keys(awardsConfig).forEach(awardKey => {
        const leaderboard = calculateScores(awardKey, assignedTraits);
        picks[awardKey] = leaderboard[0]; // The winner is the first in the sorted list
      });
      
      setAlgorithmPicks(picks);
    };

    calculateResults();
  }, [assignedTraits]);

  // Function to open the modal
  const handleLearnWhy = (awardKey) => {
    const leaderboard = calculateScores(awardKey, assignedTraits);
    const traits = assignedTraits[awardKey] || [];
    setModalData({ awardKey, leaderboard, traits });
  };

  const getStudentName = (student) => {
    if (!student) return <span className="text-gray-500 italic">Niemand geselecteerd</span>;
    return student.name;
  };

  const getStudentById = (id) => {
    if (!id) return null;
    return mockStudents.find(s => s.id === id);
  }

  // --- [NEW] ---
  // Special mapping for award titles ONLY on the results page, as requested
  const resultsAwardTitles = {
    viral: "Most likely... Viraal te gaan",
    ceo: "Most likely... CEO te worden",
    troublemaker: "Most likely... Een marathon te lopen"
  };
  // --- [END NEW] ---

  return (
    <PageContainer title="De resultaten">
      <div className="text-center max-w-4xl mx-auto">
        <h2 className="text-2xl font-semibold text-gray-700 mb-8">Jouw intuïtie vs. het algoritme</h2>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {Object.keys(awardsConfig).map(key => {
            const userPick = getStudentById(selections[key]);
            const algorithmPick = algorithmPicks[key];
            // const isMatch = userPick && algorithmPick && userPick.id === algorithmPick.id; // [VERWIJDERD]

            return (
              // [AANGEPAST] 'isMatch' class is verwijderd
              <div key={key} className={`bg-white p-6 rounded-lg shadow-xl flex flex-col`}>
                <h3 className="text-xl font-bold text-gray-800 mb-6 truncate">{resultsAwardTitles[key]}</h3>
                <div className="space-y-4 text-left flex-grow">
                  <div>
                    <h4 className="text-sm font-semibold text-gray-600">Jouw intuïtieve keuze:</h4>
                    <p className="text-lg font-medium text-blue-600">{getStudentName(userPick)}</p>
                  </div>
                  <div>
                    <h4 className="text-sm font-semibold text-gray-600">De keuze van je algoritme:</h4>
                    <p className="text-lg font-medium text-purple-600">{getStudentName(algorithmPick)}</p>
                  </div>
                </div>
                
                {/* [VERWIJDERD] Het "Het is een match!" blok is weg */}

                {/* Learn Why Button */}
                <button
                  onClick={() => handleLearnWhy(key)}
                  className="mt-6 w-full bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition-colors"
                >
                  Ontdek waarom
                </button>
              </div>
            );
          })}
        </div>
      </div>
      
      {/* Render the modal */}
      <ResultsModal modalData={modalData} onClose={() => setModalData(null)} />
    </PageContainer>
  );
};

// --- Reflection Page ---
// --- [TRANSLATED] ---
const ReflectionPage = ({ onNext }) => (
  <PageContainer title="Reflectie">
    <div className="max-w-3xl mx-auto space-y-8 text-lg text-gray-700">
      
      <div className="bg-white p-8 rounded-lg shadow-xl">
        <h2 className="text-2xl font-semibold text-gray-800 mb-4">Hoe nauwkeurig was jouw algoritme?</h2>
        <p className="mb-6">
          Computer algoritmen kunnen fouten maken en oneerlijke resultaten creëren. Dit wordt algoritmische vooringenomenheid (bias) genoemd. Laten we drie redenen bekijken waarom algoritmen het soms mis hebben.
        </p>

        <ol className="list-decimal list-outside space-y-8 pl-6">
          
          {/* Point 1 */}
          <li className="space-y-2">
            <h3 className="text-xl font-semibold text-gray-800">
              Algoritmen hebben niet alle informatie
            </h3>
            <p>
              De 'Meest Waarschijnlijk' Machine weet alleen wat jij hem leert. Naast de kenmerken die jij hebt gekozen, kent het niet alle andere factoren die iemands persoonlijkheid vormen.
            </p>
            <p>
              Algoritmen nemen beslissingen op basis van de gegevens die je met hen deelt. Deze onvolmaakte informatie kan algoritmen vooringenomen maken.
            </p>
          </li>
          
          {/* Point 2 */}
          <li className="space-y-2">
            <h3 className="text-xl font-semibold text-gray-800">
              Algoritmen weerspiegelen menselijke meningen
            </h3>
            <p>
              Algoritmen zijn gebaseerd op de meningen van de mensen die ze creëren. Toen je de 'Meest Waarschijnlijk' Machine trainde, leerde je het om te denken zoals jij en jouw voorkeuren te volgen.
            </p>
            <p>
              Omdat alle algoritmen door mensen worden gemaakt, is het onmogelijk om hun meningen te verwijderen uit de beslissingen die de algoritmen nemen. Deze meningen kunnen algoritmen ook vooringenomen maken.
            </p>
          </li>
          
          {/* Point 3 */}
          <li className="space-y-2">
            <h3 className="text-xl font-semibold text-gray-800">
              Algoritmen kunnen fouten herhalen en vermenigvuldigen
            </h3>
            <p>
              Algoritmen herhalen hun instructies, dus herhalen en vermenigvuldigen ze ook hun fouten. De 'Meest Waarschijnlijk' Machine heeft 9 studenten gecategoriseerd, maar stel je voor dat je het gebruikt om iedereen op je school, in je stad of staat te categoriseren.
            </p>
            <p>
              Zelfs één kleine fout in een algoritme kan een enorme impact hebben.
            </p>
          </li>

        </ol>
      </div>

    </div>
  </PageContainer>
);

// --- [TRANSLATED] ---
const RecapPage = ({ onNext }) => (
  <PageContainer title="Samenvatting">
    <div className="max-w-3xl mx-auto bg-white p-8 rounded-lg shadow-xl">
      <h2 className="text-2xl font-semibold text-gray-800 mb-6">Belangrijkste Punten</h2>
      <ul className="list-disc list-inside space-y-4 text-gray-600 text-lg">
        <li>
          <strong>Algoritmen zijn hulpmiddelen die door mensen zijn gebouwd.</strong> Ze weerspiegelen de doelen, waarden en vooroordelen van hun makers.
        </li>
        <li>
          <strong>Verschillende inputs en gewichten leiden tot verschillende uitkomsten.</strong> Een kleine wijziging in de regels van een algoritme kan een grote impact hebben op iemands leven.
        </li>
        <li>
          <strong>"Eerlijkheid" is complex.</strong> Een algoritme dat op het eerste gezicht neutraal lijkt, kan nog steeds oneerlijke resultaten opleveren als de gegevens vooringenomen zijn.
        </li>
        <li>
          <strong>Transparantie is cruciaal.</strong> Het is belangrijk om te vragen welke factoren een algoritme gebruikt en hoe het wordt "afgesteld".
        </li>
      </ul>
      <div className="text-center mt-12">
        <button
          onClick={() => onNext(0)} // Reset to first page
          className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full text-lg transition duration-300 shadow-md hover:shadow-lg"
        >
          Opnieuw Beginnen
        </button>
      </div>
    </div>
  </PageContainer>
);

// --- Navigation ---
// --- [TRANSLATED] ---
const Navigation = ({ currentPageIndex, setCurrentPage }) => {
  const onNext = () => {
    if (currentPageIndex < PAGES.length - 1) {
      setCurrentPage(currentPageIndex + 1);
    }
  };

  const onBack = () => {
    if (currentPageIndex > 0) {
      setCurrentPage(currentPageIndex - 1);
    }
  };

  const canGoBack = currentPageIndex > 0;
  const canGoNext = currentPageIndex < PAGES.length - 1;

  if (currentPageIndex === 0) return null;
  const showNext = currentPageIndex !== PAGES.length - 1;

  return (
    <footer className="bg-white border-t border-gray-200 sticky bottom-0 z-10 shadow-inner">
      <div className="container mx-auto px-4 sm:px-8 py-4 max-w-5xl flex justify-between items-center">
        <button
          onClick={onBack}
          disabled={!canGoBack}
          className={`font-medium py-2 px-6 rounded-full transition duration-300 ${
            canGoBack
              ? 'bg-gray-200 hover:bg-gray-300 text-gray-700'
              : 'bg-gray-100 text-gray-400 cursor-not-allowed'
          }`}
        >
          Terug
        </button>
        <div className="text-sm text-gray-500">
          Pagina {currentPageIndex} van {PAGES.length - 1}
        </div>
        {showNext && (
          <button
            onClick={onNext}
            disabled={!canGoNext}
            className={`font-bold py-2 px-6 rounded-full transition duration-300 ${
              canGoNext
                ? 'bg-blue-600 hover:bg-blue-700 text-white'
                : 'bg-blue-300 text-white cursor-not-allowed'
            }`}
          >
            Volgende
          </button>
        )}
      </div>
    </footer>
  );
};

// --- Main App Component ---

export default function App() {
  const [currentPageIndex, setCurrentPageIndex] = useState(0);
  
  const getInitialSelections = () => ({
    viral: null, // student id
    ceo: null,   // student id
    troublemaker: null // student id
  });
  
  const getInitialTraits = () => ({
    viral: [], // array of trait objects
    ceo: [],   // array of trait objects
    troublemaker: [] // array of trait objects
  });

  const [selections, setSelections] = useState(getInitialSelections());
  const [assignedTraits, setAssignedTraits] =useState(getInitialTraits());

  // Scroll to top on page change
  useEffect(() => {
    window.scrollTo(0, 0);
  }, [currentPageIndex]);

  const onNext = (pageIndex) => {
      if (typeof pageIndex === 'number') {
          if (pageIndex === 0) {
            // Reset state when "Start Over" is clicked
            setSelections(getInitialSelections());
            setAssignedTraits(getInitialTraits());
          }
          setCurrentPageIndex(pageIndex);
      } else if (currentPageIndex < PAGES.length - 1) {
          setCurrentPageIndex(currentPageIndex + 1);
      }
  };
  
  // [CODE REVIEW FIX]
  // The problematic useEffect that reset 'assignedTraits'
  // when navigating to 'create-algorithm' has been REMOVED.
  // The state reset is now correctly handled *only* by the
  // "Start Over" button (in the onNext function).

  // --- renderPage function ---
  const renderPage = () => {
    const pageName = PAGES[currentPageIndex];

    switch (pageName) {
      case 'home':
        return <HomePage onNext={onNext} />;
      case 'objectives':
        return <ObjectivesPage onNext={onNext} />;
      case 'introduction':
        return <IntroductionPage onNext={onNext} />;
      case 'meet-the-class':
        return <MeetTheClassPage onNext={onNext} />;
      case 'predict-winners':
        return <PredictWinnersPage onNext={onNext} selections={selections} setSelections={setSelections} />;
      case 'create-algorithm':
        return <CreateAlgorithmPage onNext={onNext} assignedTraits={assignedTraits} setAssignedTraits={setAssignedTraits} />;
      case 'tune-algorithm':
        return <TuneAlgorithmPage onNext={onNext} assignedTraits={assignedTraits} setAssignedTraits={setAssignedTraits} />;
      case 'results':
        return <ResultsPage onNext={onNext} selections={selections} assignedTraits={assignedTraits} />;
      case 'reflection':
        return <ReflectionPage onNext={onNext} />;
      case 'recap':
        return <RecapPage onNext={onNext} />;
      default:
        return <HomePage onNext={onNext} />;
    }
  };
  
  const pageTitle = PAGES[currentPageIndex] ? PAGES[currentPageIndex].replace(/-/g, ' ') : '';
  const titleCasePageTitle = pageTitle.charAt(0).toUpperCase() + pageTitle.slice(1);

  return (
    <div className="min-h-screen bg-gray-50 font-sans flex flex-col">
      {/* Header Bar */}
      {/* --- [TRANSLATED] --- */}
      <header className="bg-white shadow-sm sticky top-0 z-10">
        <div className="container mx-auto px-4 sm:px-8 max-w-5xl h-16 flex items-center">
           <h1 className="text-lg font-semibold text-gray-800">
             De 'most likely' machine
             <span className="text-base font-normal text-gray-500 ml-2">/ {titleCasePageTitle}</span>
           </h1>
        </div>
      </header>

      {/* Main Content */}
      <main className="flex-grow">
        {renderPage()}
      </main>

      {/* Navigation Footer */}
      <Navigation
        currentPageIndex={currentPageIndex}
        setCurrentPage={setCurrentPageIndex}
      />
    </div>
  );
}
